#[rustfmt::skip]
use libm::{
    acos,
    acosf,
    acosh,
    acoshf,
    asin,
    asinf,
    asinh,
    asinhf,
    atan,
    atan2,
    atan2f,
    atanf,
    atanh,
    atanhf,
    cbrt,
    cbrtf,
    ceil,
    ceilf,
    copysign,
    copysignf,
    cos,
    cosf,
    cosh,
    coshf,
    erf,
    erfc,
    erfcf,
    erff,
    exp,
    exp2,
    exp2f,
    exp10,
    exp10f,
    expf,
    expm1,
    expm1f,
    fabs,
    fabsf,
    fdim,
    fdimf,
    floor,
    floorf,
    fma,
    fmaf,
    fmax,
    fmaxf,
    fmin,
    fminf,
    fmod,
    fmodf,
    frexp,
    frexpf,
    hypot,
    hypotf,
    ilogb,
    ilogbf,
    j0,
    j0f,
    j1,
    j1f,
    jn,
    jnf,
    ldexp,
    ldexpf,
    lgamma,
    lgamma_r,
    lgammaf,
    lgammaf_r,
    log,
    log1p,
    log1pf,
    log2,
    log2f,
    log10,
    log10f,
    logf,
    modf,
    modff,
    nextafter,
    nextafterf,
    pow,
    powf,
    remainder,
    remainderf,
    remquo,
    remquof,
    round,
    roundf,
    scalbn,
    scalbnf,
    sin,
    sincos,
    sincosf,
    sinf,
    sinh,
    sinhf,
    sqrt,
    sqrtf,
    tan,
    tanf,
    tanh,
    tanhf,
    tgamma,
    tgammaf,
    trunc,
    truncf,
    y0,
    y0f,
    y1,
    y1f,
    yn,
    ynf,
};
use approx::assert_relative_eq;

fn main() {
    let pi = f64::from_bits(0x400921fb000FD5DD);
    assert_relative_eq!(sin(0.0 * pi), 0.0);
    assert_relative_eq!(sin(0.5 * pi), 1.0);
    assert_relative_eq!(sin(1.0 * pi), 0.0);
    assert_relative_eq!(sin(1.5 * pi), -1.0);
}
